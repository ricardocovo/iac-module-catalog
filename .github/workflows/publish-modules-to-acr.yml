name: Publish Bicep Modules to ACR

on:
  # push:
  #   branches:
  #     - main
  #   paths:
  #     - 'catalog/**/main.bicep'
  workflow_dispatch:
    inputs:
      force_publish:
        description: 'Force publish even if version exists'
        required: false
        type: boolean
        default: false
      cleanup_orphaned:
        description: 'Remove modules from ACR that no longer exist in codebase'
        required: false
        type: boolean
        default: false

# Security: Default to read-only permissions
permissions:
  contents: read
  id-token: write # Required for OIDC authentication to Azure

# Prevent concurrent publishes
concurrency:
  group: publish-modules
  cancel-in-progress: false

env:
  BICEP_VERSION: '0.24.24'

jobs:
  detect-changed-modules:
    name: Detect Changed Modules
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has-changes: ${{ steps.set-matrix.outputs.has-changes }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history for accurate diff

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v44
        with:
          files: |
            catalog/**/main.bicep
          json: true

      - name: Set module matrix
        id: set-matrix
        run: |
          set -euo pipefail
          
          if [[ "${{ steps.changed-files.outputs.any_changed }}" == "true" ]] || [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "Detected changed Bicep modules or manual trigger"
            
            # Build matrix of all modules (not just changed ones for workflow_dispatch)
            modules='[]'
            
            if [[ "${{ github.event_name }}" == "workflow_dispatch" ]] || [[ "${{ inputs.force_publish }}" == "true" ]]; then
              # Publish all modules on manual trigger
              modules=$(find catalog -name "main.bicep" -type f | jq -R -s -c 'split("\n")[:-1]')
            else
              # Only publish changed modules
              modules=$(echo '${{ steps.changed-files.outputs.all_changed_files }}' | jq -c .)
            fi
            
            echo "matrix=$modules" >> $GITHUB_OUTPUT
            echo "has-changes=true" >> $GITHUB_OUTPUT
            
            echo "Modules to process:"
            echo "$modules" | jq -r '.[]'
          else
            echo "No module changes detected"
            echo "matrix=[]" >> $GITHUB_OUTPUT
            echo "has-changes=false" >> $GITHUB_OUTPUT
          fi

  publish-modules:
    name: Publish Module
    needs: detect-changed-modules
    if: needs.detect-changed-modules.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    outputs:
      publish-results: ${{ steps.collect-results.outputs.results }}
    strategy:
      fail-fast: false
      max-parallel: 5
      matrix:
        module-path: ${{ fromJson(needs.detect-changed-modules.outputs.matrix) }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Bicep CLI
        run: |
          curl -Lo bicep https://github.com/Azure/bicep/releases/download/v${{ env.BICEP_VERSION }}/bicep-linux-x64
          chmod +x ./bicep
          sudo mv ./bicep /usr/local/bin/bicep
          bicep --version

      - name: Extract module metadata
        id: metadata
        run: |
          set -euo pipefail
          
          MODULE_PATH="${{ matrix.module-path }}"
          
          # Extract category, module name, and version from path
          # Example: catalog/ai/cognitive-services-account/0.7.0/main.bicep
          CATEGORY=$(echo "$MODULE_PATH" | cut -d'/' -f2)
          MODULE_NAME=$(echo "$MODULE_PATH" | cut -d'/' -f3)
          VERSION=$(echo "$MODULE_PATH" | cut -d'/' -f4)
          
          if [[ -z "$VERSION" ]]; then
            echo "ERROR: Could not extract version from $MODULE_PATH"
            exit 1
          fi
          
          # Validate version format (semantic versioning)
          if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "ERROR: Invalid version format: $VERSION (expected x.y.z)"
            exit 1
          fi
          
          # Construct ACR repository name: {category}/{module-name}
          ACR_REPO="${CATEGORY}/${MODULE_NAME}"
          
          echo "category=$CATEGORY" >> $GITHUB_OUTPUT
          echo "module-name=$MODULE_NAME" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "acr-repo=$ACR_REPO" >> $GITHUB_OUTPUT
          echo "module-dir=$(dirname "$MODULE_PATH")" >> $GITHUB_OUTPUT
          echo "module-path=$MODULE_PATH" >> $GITHUB_OUTPUT
          
          echo "üì¶ Module: $MODULE_NAME"
          echo "üìÇ Category: $CATEGORY"
          echo "üè∑Ô∏è  Version: $VERSION"
          echo "üéØ ACR Repo: $ACR_REPO"

      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Check if version exists in ACR
        id: check-version
        run: |
          set -euo pipefail
          
          ACR_NAME="${{ secrets.ACR_NAME }}"
          ACR_REPO="${{ steps.metadata.outputs.acr-repo }}"
          VERSION="${{ steps.metadata.outputs.version }}"
          
          # Check if tag exists
          if az acr repository show-tags \
              --name "$ACR_NAME" \
              --repository "$ACR_REPO" \
              --output tsv 2>/dev/null | grep -q "^${VERSION}$"; then
            echo "Version $VERSION already exists in $ACR_REPO"
            echo "exists=true" >> $GITHUB_OUTPUT
            
            if [[ "${{ inputs.force_publish }}" == "true" ]]; then
              echo "Force publish enabled - will overwrite existing version"
              echo "should-publish=true" >> $GITHUB_OUTPUT
            else
              echo "Skipping publish"
              echo "should-publish=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "Version $VERSION does not exist - will publish"
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "should-publish=true" >> $GITHUB_OUTPUT
          fi

      - name: Build Bicep module
        if: steps.check-version.outputs.should-publish == 'true'
        run: |
          set -euo pipefail
          
          MODULE_DIR="${{ steps.metadata.outputs.module-dir }}"
          
          echo "Building module in $MODULE_DIR"
          cd "$MODULE_DIR"
          
          # Build and validate
          bicep build main.bicep --outfile /tmp/main.json
          
          echo "‚úÖ Module built successfully"

      - name: Publish to ACR
        id: publish
        if: steps.check-version.outputs.should-publish == 'true'
        run: |
          set -euo pipefail
          
          ACR_NAME="${{ secrets.ACR_NAME }}"
          ACR_REPO="${{ steps.metadata.outputs.acr-repo }}"
          VERSION="${{ steps.metadata.outputs.version }}"
          MODULE_DIR="${{ steps.metadata.outputs.module-dir }}"
          
          # Build full ACR path
          ACR_TARGET="${ACR_NAME}.azurecr.io/${ACR_REPO}:${VERSION}"
          
          echo "Publishing to: $ACR_TARGET"
          
          # Publish module to ACR
          cd "$MODULE_DIR"
          az bicep publish \
            --file main.bicep \
            --target "br:${ACR_TARGET}" \
            --force
          
          echo "‚úÖ Published $ACR_REPO:$VERSION to ACR"
          echo "publish-success=true" >> $GITHUB_OUTPUT

      - name: Tag major version
        if: steps.publish.outputs.publish-success == 'true'
        continue-on-error: true
        run: |
          set -euo pipefail
          
          ACR_NAME="${{ secrets.ACR_NAME }}"
          ACR_REPO="${{ steps.metadata.outputs.acr-repo }}"
          VERSION="${{ steps.metadata.outputs.version }}"
          MAJOR_VERSION=$(echo "$VERSION" | cut -d. -f1)
          
          echo "Tagging major version: v${MAJOR_VERSION}"
          
          # Use az acr import with explicit subscription to create major version tag
          # This requires Contributor or AcrPush + Reader on the ACR resource
          az acr import \
            --name "$ACR_NAME" \
            --subscription "${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
            --source "${ACR_NAME}.azurecr.io/${ACR_REPO}:${VERSION}" \
            --image "${ACR_REPO}:v${MAJOR_VERSION}" \
            --force
          
          echo "‚úÖ Tagged as v${MAJOR_VERSION}"

      - name: Log publish status
        if: always()
        run: |
          # Determine the actual status for this module
          if [[ "${{ steps.check-version.outputs.should-publish }}" != "true" ]]; then
            if [[ "${{ steps.check-version.outputs.exists }}" == "true" ]]; then
              echo "‚è≠Ô∏è Version ${{ steps.metadata.outputs.version }} already exists - skipped"
            else
              echo "‚ö†Ô∏è Module skipped"
            fi
          elif [[ "${{ steps.publish.outputs.publish-success }}" == "true" ]]; then
            echo "‚úÖ Successfully published ${{ steps.metadata.outputs.acr-repo }}:${{ steps.metadata.outputs.version }}"
          elif [[ "${{ steps.publish.outcome }}" == "failure" ]]; then
            echo "‚ùå Failed to publish ${{ steps.metadata.outputs.acr-repo }}:${{ steps.metadata.outputs.version }}"
          else
            echo "‚ö†Ô∏è Unknown status for ${{ steps.metadata.outputs.acr-repo }}:${{ steps.metadata.outputs.version }}"
          fi

  cleanup-orphaned-modules:
    name: Cleanup Orphaned Modules
    needs: [detect-changed-modules, publish-modules]
    if: always() && github.event_name == 'workflow_dispatch' && inputs.cleanup_orphaned == true
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Discover codebase modules
        id: codebase-modules
        run: |
          set -euo pipefail
          
          echo "Discovering modules in codebase..."
          
          # Build list of all module paths in codebase
          # Format: category/module-name (e.g., ai/cognitive-services-account)
          CODEBASE_MODULES=()
          
          while IFS= read -r module_path; do
            # Extract category and module name from path
            # Example: catalog/ai/cognitive-services-account/0.7.0/main.bicep -> ai/cognitive-services-account
            CATEGORY=$(echo "$module_path" | cut -d'/' -f2)
            MODULE_NAME=$(echo "$module_path" | cut -d'/' -f3)
            MODULE_KEY="${CATEGORY}/${MODULE_NAME}"
            
            # Add to array if not already present
            if [[ ! " ${CODEBASE_MODULES[*]} " =~ " ${MODULE_KEY} " ]]; then
              CODEBASE_MODULES+=("$MODULE_KEY")
            fi
          done < <(find catalog -name "main.bicep" -type f)
          
          # Sort and output
          printf '%s\n' "${CODEBASE_MODULES[@]}" | sort -u > /tmp/codebase-modules.txt
          
          echo "Found $(wc -l < /tmp/codebase-modules.txt) unique modules in codebase:"
          cat /tmp/codebase-modules.txt

      - name: Discover ACR modules
        id: acr-modules
        run: |
          set -euo pipefail
          
          ACR_NAME="${{ secrets.ACR_NAME }}"
          
          echo "Discovering modules in ACR..."
          
          # List all repositories in ACR with bicep/ prefix
          ACR_MODULES=()
          
          # Get all repositories
          while IFS= read -r repo; do
            # Remove 'bicep/' prefix to get category/module-name format
            if [[ "$repo" == bicep/* ]]; then
              MODULE_KEY="${repo#bicep/}"
              ACR_MODULES+=("$MODULE_KEY")
            fi
          done < <(az acr repository list --name "$ACR_NAME" --output tsv 2>/dev/null | grep "^bicep/" || true)
          
          # Sort and output
          printf '%s\n' "${ACR_MODULES[@]}" | sort -u > /tmp/acr-modules.txt
          
          echo "Found $(wc -l < /tmp/acr-modules.txt) unique modules in ACR:"
          cat /tmp/acr-modules.txt

      - name: Identify orphaned modules
        id: orphaned-modules
        run: |
          set -euo pipefail
          
          echo "Identifying orphaned modules (in ACR but not in codebase)..."
          
          # Find modules in ACR that are NOT in codebase
          comm -13 /tmp/codebase-modules.txt /tmp/acr-modules.txt > /tmp/orphaned-modules.txt
          
          ORPHANED_COUNT=$(wc -l < /tmp/orphaned-modules.txt)
          
          echo "orphaned-count=$ORPHANED_COUNT" >> $GITHUB_OUTPUT
          
          if [[ $ORPHANED_COUNT -gt 0 ]]; then
            echo "Found $ORPHANED_COUNT orphaned module(s):"
            cat /tmp/orphaned-modules.txt
          else
            echo "No orphaned modules found"
          fi

      - name: Remove orphaned modules
        if: steps.orphaned-modules.outputs.orphaned-count > 0
        run: |
          set -euo pipefail
          
          ACR_NAME="${{ secrets.ACR_NAME }}"
          
          echo "Removing orphaned modules from ACR..."
          echo ""
          
          REMOVED_COUNT=0
          FAILED_COUNT=0
          
          while IFS= read -r module_key; do
            if [[ -z "$module_key" ]]; then
              continue
            fi
            
            ACR_REPO="bicep/${module_key}"
            
            echo "üóëÔ∏è  Removing: $ACR_REPO"
            
            if az acr repository delete \
                --name "$ACR_NAME" \
                --repository "$ACR_REPO" \
                --yes 2>&1; then
              echo "‚úÖ Removed: $ACR_REPO"
              ((REMOVED_COUNT++))
            else
              echo "‚ùå Failed to remove: $ACR_REPO"
              ((FAILED_COUNT++))
            fi
            
            echo ""
          done < /tmp/orphaned-modules.txt
          
          echo "removed-count=$REMOVED_COUNT" >> $GITHUB_OUTPUT
          echo "failed-count=$FAILED_COUNT" >> $GITHUB_OUTPUT
          
          echo "Summary: Removed $REMOVED_COUNT, Failed $FAILED_COUNT"

      - name: Cleanup summary
        if: always()
        run: |
          echo "## üßπ Orphaned Module Cleanup" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          ORPHANED_COUNT="${{ steps.orphaned-modules.outputs.orphaned-count }}"
          
          if [[ "$ORPHANED_COUNT" == "0" ]]; then
            echo "‚úÖ No orphaned modules found. ACR is in sync with codebase." >> $GITHUB_STEP_SUMMARY
          else
            echo "**Orphaned modules found:** $ORPHANED_COUNT" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            if [[ -f "/tmp/orphaned-modules.txt" ]]; then
              echo "### Modules Removed from ACR" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "| Module Path | Status |" >> $GITHUB_STEP_SUMMARY
              echo "|-------------|--------|" >> $GITHUB_STEP_SUMMARY
              
              while IFS= read -r module_key; do
                if [[ -n "$module_key" ]]; then
                  echo "| \`bicep/${module_key}\` | ‚úÖ Removed |" >> $GITHUB_STEP_SUMMARY
                fi
              done < /tmp/orphaned-modules.txt
            fi
          fi

  summary:
    name: Publish Summary
    needs: [detect-changed-modules, publish-modules, cleanup-orphaned-modules]
    if: always() && needs.detect-changed-modules.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Generate summary
        run: |
          set -euo pipefail
          
          echo "# üöÄ Bicep Module Publish Workflow" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow Run:** [\#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.publish-modules.result }}" == "success" ]]; then
            echo "‚úÖ All modules processed successfully" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.publish-modules.result }}" == "failure" ]]; then
            echo "‚ùå Some modules failed to publish" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è Modules processed with warnings" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üì¶ Module Processing" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Module details are available in individual job logs above." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Check each module's publish job for specific status information." >> $GITHUB_STEP_SUMMARY
          
          # Add cleanup summary if it ran
          if [[ "${{ needs.cleanup-orphaned-modules.result }}" != "skipped" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "---" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## üßπ Cleanup Status" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            if [[ "${{ needs.cleanup-orphaned-modules.result }}" == "success" ]]; then
              echo "‚úÖ Orphaned module cleanup completed successfully" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚ö†Ô∏è Orphaned module cleanup completed with warnings or errors" >> $GITHUB_STEP_SUMMARY
            fi
          fi
